// index.js (patched)
const express = require("express");
const app = express();
const fs = require("fs");
const path = require("path");

const DATA_DIR = path.join(__dirname, "data");
if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR);

const TASKS_FILE = path.join(DATA_DIR, "tasks.json");
const USERS_FILE = path.join(DATA_DIR, "users.json");

app.use(express.static("static"));
app.use(express.json());

/* -------------------- configuration -------------------- */

const WIP_LIMITS = {
  Ready: null,
  InProgress: 5,
  Blocked: 10,
  Suspended: null,
  Review: 3,
  Done: null
};

/* -------------------- file-backed stores -------------------- */

function loadJson(filePath, fallback) {
  try {
    const raw = fs.readFileSync(filePath, "utf8");
    if (!raw || raw.trim() === "") return fallback;
    return JSON.parse(raw);
  } catch (err) {
    if (err && err.code === "ENOENT") return fallback;
    console.error(`Error loading ${filePath}:`, err);
    return fallback;
  }
}

function saveJson(filePath, obj) {
  try {
    const tmp = filePath + ".tmp";
    fs.writeFileSync(tmp, JSON.stringify(obj, null, 2), "utf8");
    fs.renameSync(tmp, filePath);
  } catch (err) {
    console.error(`Error saving ${filePath}:`, err);
  }
}

function loadTasks() { return loadJson(TASKS_FILE, []); }
function saveTasks(tasks) { saveJson(TASKS_FILE, tasks); }

function loadUsers() { return loadJson(USERS_FILE, {}); }
function saveUsers(users) { saveJson(USERS_FILE, users); }

/* -------------------- mutation queue -------------------- */

const mutationQueue = [];
let mutationProcessing = false;

function enqueueMutation(mutFn) {
  return new Promise((resolve, reject) => {
    mutationQueue.push({ mutFn, resolve, reject });
    if (!mutationProcessing) processMutationQueue();
  });
}

async function processMutationQueue() {
  mutationProcessing = true;
  while (mutationQueue.length) {
    const { mutFn, resolve, reject } = mutationQueue.shift();
    try {
      const result = await mutFn();
      resolve(result);
    } catch (err) {
      console.error("Mutation error:", err);
      reject(err);
    }
  }
  mutationProcessing = false;
}

/* -------------------- utilities -------------------- */

function genId() {
  // Date-based id with small random suffix to avoid same-ms collisions
  return `${Date.now()}-${Math.floor(Math.random() * 100000)}`;
}

/* -------------------- user points -------------------- */

function awardPoints(userKey, points, reason = '') {
  if (!userKey) return null;
  const users = loadUsers();
  const key = String(userKey).trim();
  if (!key) return null;
  if (!users[key]) users[key] = { id: key, name: key, points: 0, history: [] };
  const u = users[key];
  const pts = Math.max(0, Math.round(points || 0));
  u.points = (u.points || 0) + pts;
  u.history = u.history || [];
  u.history.push({ ts: new Date().toISOString(), points: pts, reason });
  saveUsers(users);
  return u;
}

/* -------------------- WIP helpers -------------------- */

function wouldExceedWip(tasks, targetState, excludeTaskId = null) {
  const limit = WIP_LIMITS[targetState];
  if (!Number.isFinite(limit)) return false;
  const count = tasks.filter(t => t.state === targetState && t.id !== excludeTaskId).length;
  return (count + 1) > limit;
}

/* -------------------- dependency / cycle helpers -------------------- */

/**
 * wouldCreateCycle(tasks, taskId, depId)
 * returns true if adding depId as a dependency of taskId would create a cycle.
 */
function wouldCreateCycle(tasks, taskId, depId) {
  if (taskId === depId) return true;
  const byId = new Map(tasks.map(t => [t.id, t]));
  // DFS from depId following dependencies to see if we reach taskId
  const seen = new Set();
  const stack = [depId];
  while (stack.length) {
    const id = stack.pop();
    if (id === taskId) return true;
    if (seen.has(id)) continue;
    seen.add(id);
    const t = byId.get(id);
    if (!t || !Array.isArray(t.dependencies)) continue;
    for (const d of t.dependencies) {
      if (!seen.has(d)) stack.push(d);
    }
  }
  return false;
}

/* -------------------- priority engine -------------------- */

function computePriorities(tasks, nowIso = new Date(), config = {}) {
  const cfg = {
    MAX_WINDOW: config.MAX_WINDOW_days ?? 30,
    decay: config.decay ?? 0.5,
    w_u: config.w_u ?? 0.4,
    w_i: config.w_i ?? 0.6
  };

  const now = (nowIso instanceof Date) ? nowIso : new Date(nowIso);

  const byId = new Map(tasks.map(t => [t.id, t]));
  const dependents = new Map();
  for (const t of tasks) dependents.set(t.id, []);
  for (const t of tasks) {
    (t.dependencies || []).forEach(dep => {
      if (dependents.has(dep)) dependents.get(dep).push(t.id);
    });
  }

  // Kahn topo
  const inDegree = new Map();
  for (const t of tasks) inDegree.set(t.id, 0);
  for (const t of tasks) {
    for (const dep of (t.dependencies || [])) {
      if (!byId.has(dep)) {
        console.warn(`Task ${t.id} depends on missing task ${dep}`);
        continue;
      }
      inDegree.set(t.id, (inDegree.get(t.id) || 0) + 1);
    }
  }

  const q = [];
  for (const [id, deg] of inDegree.entries()) if (deg === 0) q.push(id);
  const topo = [];
  while (q.length) {
    const id = q.shift();
    topo.push(id);
    for (const kid of (dependents.get(id) || [])) {
      if (!inDegree.has(kid)) continue;
      inDegree.set(kid, inDegree.get(kid) - 1);
      if (inDegree.get(kid) === 0) q.push(kid);
    }
  }
  const topoSet = new Set(topo);
  const cycleNodes = tasks.filter(t => !topoSet.has(t.id)).map(t => t.id);
  const deadlockSet = new Set(cycleNodes);

  // raw importance (back-propagation)
  const rawR = new Map();
  for (const t of tasks) rawR.set(t.id, 0);
  for (let i = topo.length - 1; i >= 0; --i) {
    const id = topo[i];
    let sum = 0;
    for (const childId of (dependents.get(id) || [])) {
      const childRaw = rawR.get(childId) || 0;
      sum += 1 + cfg.decay * childRaw;
    }
    rawR.set(id, sum);
  }
  for (const id of cycleNodes) rawR.set(id, 0);

  // map raw importance to percentile (robust to duplicates)
  const allRaw = Array.from(rawR.values()).sort((a, b) => a - b);
  function rawToPercentile(val) {
    if (allRaw.length <= 1) return 0;
    // count how many values are <= val (so duplicates are handled)
    const lessOrEqual = allRaw.filter(v => v <= val).length;
    const denom = allRaw.length - 1;
    const pct = denom > 0 ? ((lessOrEqual - 1) / denom) * 100 : 0;
    return Math.max(0, Math.min(100, Math.round(pct)));
  }

  function computeUrgency(task) {
    if (typeof task.urgency === "number" && !isNaN(task.urgency)) {
      return Math.max(0, Math.min(100, Math.round(task.urgency)));
    }
    const dl = task.deadline;
    if (!dl) return 0;
    const d = new Date(dl);
    if (isNaN(d.getTime())) return 0;
    const msLeft = d.getTime() - now.getTime();
    const daysLeft = msLeft / (1000 * 60 * 60 * 24);
    if (daysLeft <= 0) return 100;
    if (daysLeft >= cfg.MAX_WINDOW) return 0;
    return Math.max(0, Math.min(100, Math.round(100 * (1 - daysLeft / cfg.MAX_WINDOW))));
  }

  return tasks.map(t => {
    const r = rawR.get(t.id) || 0;
    const I = rawToPercentile(r);
    const U = computeUrgency(t);
    const P = Math.max(0, Math.min(100, Math.round(cfg.w_u * U + cfg.w_i * I)));
    return Object.assign({}, t, {
      importanceRaw: r,
      importancePercentile: I,
      urgency: U,
      priority: P,
      deadlock: deadlockSet.has(t.id)
    });
  });
}

/* -------------------- recompute wrapper -------------------- */

function recomputeAllPriorities(tasks = null) {
  const cfg = { MAX_WINDOW_days: 30, decay: 0.5, w_u: 0.4, w_i: 0.6 };
  const ts = tasks ?? loadTasks();
  const updated = computePriorities(ts, new Date(), cfg);
  const changed = [];
  for (const u of updated) {
    const t = ts.find(x => x.id === u.id);
    if (!t) continue;
    const before = { priority: t.priority, urgency: t.urgency, importancePercentile: t.importancePercentile };
    t.priority = u.priority;
    t.urgency = u.urgency;
    t.importancePercentile = u.importancePercentile;
    t.importanceRaw = u.importanceRaw;
    t.deadlock = u.deadlock;
    if (before.priority !== t.priority || before.urgency !== t.urgency || before.importancePercentile !== t.importancePercentile) {
      changed.push({ id: t.id, before, after: { priority: t.priority, urgency: t.urgency, importancePercentile: t.importancePercentile } });
    }
  }
  if (changed.length) console.log("Priorities/metrics changed:", changed);
  saveTasks(ts);
  return ts;
}

/* -------------------- HTTP API -------------------- */

app.get("/", (req, res) => res.send("Server running."));

app.get("/tasks", (req, res) => {
  res.json(loadTasks());
});

app.post("/tasks", async (req, res) => {
  try {
    const created = await enqueueMutation(async () => {
      const tasks = loadTasks();

      // sanitize and validate dependencies (if client provided them)
      const deps = Array.isArray(req.body.dependencies) ? req.body.dependencies : [];
      const validDeps = deps.filter(d => tasks.some(t => t.id === d));
      if (deps.length && validDeps.length !== deps.length) {
        console.warn("POST /tasks: some dependencies were invalid and dropped");
      }

      // prevent cycles when creating with dependencies
      for (const depId of validDeps) {
        if (wouldCreateCycle(tasks, depId /* temp: treat dep as child? */, depId)) {
          // unlikely here but keep safe â€” this check is more useful when adding dependencies later
        }
      }

      const titleRaw = req.body.title || "Untitled Task";
      const title = String(titleRaw).trim().slice(0, 200);
      const description = (req.body.description || "").toString().trim();

      const newTask = {
        id: genId(),
        title: title || "Untitled Task",
        description: description || "",
        state: "Ready",
        deadline: req.body.deadline || undefined,
        dependencies: validDeps,
        picker: null,
        points_snapshot: undefined,
        picked_at: undefined,
        awarded: undefined,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        meta: {}
      };
      tasks.push(newTask);

      recomputeAllPriorities(tasks);
      saveTasks(tasks);
      return newTask;
    });
    res.status(201).json(created);
  } catch (err) {
    console.error("POST /tasks error:", err);
    if (err && err.status && err.body) return res.status(err.status).json(err.body);
    res.status(500).json({ error: "Internal error creating task" });
  }
});

app.patch("/tasks/:id/state", async (req, res) => {
  try {
    const result = await enqueueMutation(async () => {
      const tasks = loadTasks();
      const task = tasks.find(t => t.id === req.params.id);
      if (!task) throw { status: 404, body: { error: "Task not found" } };

      const newState = req.body.state;
      // Validate provided state
      if (typeof newState !== "string" || !newState) {
        throw { status: 400, body: { error: "Missing or invalid 'state' in body" } };
      }

      const newPickerRaw = ('picker' in req.body) ? req.body.picker : undefined;
      const newPicker = (typeof newPickerRaw === 'string') ? newPickerRaw.trim() : newPickerRaw;
      const note = req.body.note || "";

      if (wouldExceedWip(tasks, newState, task.id)) {
        throw { status: 400, body: { error: `WIP limit exceeded for ${newState}. Limit: ${WIP_LIMITS[newState]}` } };
      }

      function persistAndReturn() {
        recomputeAllPriorities(tasks);
        saveTasks(tasks);
        return task;
      }

      if (newState === "InProgress") {
        task.state = "InProgress";
        if (newPicker !== undefined && newPicker !== '') {
          task.picker = newPicker;
          task.picker_history = task.picker_history || [];
          task.picker_history.push({ ts: new Date().toISOString(), picker: newPicker, action: "picked" });
        }
        if (typeof task.points_snapshot !== "number") {
          const updated = computePriorities(tasks, new Date(), { MAX_WINDOW_days: 30, decay: 0.5, w_u: 0.4, w_i: 0.6 });
          const u = updated.find(x => x.id === task.id);
          const snap = (u && typeof u.priority === "number") ? u.priority : (task.priority || 0);
          task.points_snapshot = snap;
          task.points_snapshot_created_at = new Date().toISOString();
          task.points_snapshot_created_by = task.picker || newPicker || null;
          task.picked_at = new Date().toISOString();
          task.points_history = task.points_history || [];
          task.points_history.push({ ts: task.points_snapshot_created_at, snapshot: snap, by: task.points_snapshot_created_by });
        }
        task.updated_at = new Date().toISOString();
        return persistAndReturn();
      }

      if (newState === "Blocked") {
        if (wouldExceedWip(tasks, "Blocked", task.id)) {
          throw { status: 400, body: { error: `WIP limit exceeded for Blocked. Limit: ${WIP_LIMITS["Blocked"]}` } };
        }
        task.state = "Blocked";
        if (newPicker !== undefined && newPicker !== '') {
          task.picker = newPicker;
          task.picker_history = task.picker_history || [];
          task.picker_history.push({ ts: new Date().toISOString(), picker: newPicker, action: "blocked" });
        }
        task.meta = task.meta || {};
        task.meta.block_note = note;
        task.updated_at = new Date().toISOString();
        return persistAndReturn();
      }

      if (newState === "Done") {
        const depsNotDone = (task.dependencies || []).some(depId => {
          const depTask = tasks.find(t => t.id === depId);
          return !depTask || depTask.state !== "Done";
        });
        if (depsNotDone) {
          throw { status: 400, body: { error: "Cannot complete task: dependencies not done" } };
        }

        const wasBlocked = task.state === "Blocked";
        const pointsToAward = (typeof task.points_snapshot === "number") ? Math.max(0, Math.round(task.points_snapshot)) : 0;
        const pickerKeyRaw = task.picker;
        const pickerKey = (typeof pickerKeyRaw === 'string') ? pickerKeyRaw.trim() : pickerKeyRaw;

        task.state = "Done";
        task.picker = null;
        task.updated_at = new Date().toISOString();

        // Reactivate suspended dependents whose dependencies are all done
        tasks.forEach(t => {
          if (t.state === "Suspended" && (t.dependencies || []).includes(task.id)) {
            const allDepsDone = (t.dependencies || []).every(depId => {
              const depTask = tasks.find(x => x.id === depId);
              return depTask && depTask.state === "Done";
            });
            if (allDepsDone) {
              t.state = "Ready";
              t.updated_at = new Date().toISOString();
            }
          }
        });

        if (!wasBlocked && pickerKey && pointsToAward > 0) {
          const user = awardPoints(pickerKey, pointsToAward, `Completed task ${task.id} (${task.title})`);
          console.log(`Awarded ${pointsToAward} points to ${pickerKey}`, user);
          task.awarded = { to: pickerKey, points: pointsToAward, ts: new Date().toISOString() };
          task.points_snapshot_awarded = true;
        } else {
          task.awarded = { to: null, points: 0, reason: wasBlocked ? "blocked" : "none", ts: new Date().toISOString() };
          task.points_snapshot_awarded = false;
        }

        recomputeAllPriorities(tasks);
        saveTasks(tasks);
        return task;
      }

      // Normal state change
      task.state = newState;
      if (newPicker !== undefined && newPicker !== '') {
        task.picker = newPicker;
        task.picker_history = task.picker_history || [];
        task.picker_history.push({ ts: new Date().toISOString(), picker: newPicker, action: "state-change" });
      }
      task.updated_at = new Date().toISOString();

      recomputeAllPriorities(tasks);
      saveTasks(tasks);
      return task;
    });

    if (result && result.status && result.body) {
      return res.status(result.status).json(result.body);
    }
    res.json(result);
  } catch (err) {
    if (err && err.status && err.body) {
      return res.status(err.status).json(err.body);
    }
    console.error("PATCH /tasks/:id/state error:", err);
    res.status(500).json({ error: "Internal error changing state" });
  }
});

app.patch("/tasks/:id/block", async (req, res) => {
  try {
    const updated = await enqueueMutation(async () => {
      const tasks = loadTasks();
      const task = tasks.find(t => t.id === req.params.id);
      if (!task) throw { status: 404, body: { error: "Task not found" } };

      if (wouldExceedWip(tasks, "Blocked", task.id)) {
        throw { status: 400, body: { error: `WIP limit exceeded for Blocked. Limit: ${WIP_LIMITS["Blocked"]}` } };
      }
      task.state = "Blocked";
      task.meta = task.meta || {};
      task.meta.block_note = req.body.note || "";
      task.updated_at = new Date().toISOString();
      recomputeAllPriorities(tasks);
      saveTasks(tasks);
      return task;
    });
    res.json(updated);
  } catch (err) {
    if (err && err.status && err.body) return res.status(err.status).json(err.body);
    console.error("PATCH /tasks/:id/block error:", err);
    res.status(500).json({ error: "Internal error" });
  }
});

app.patch("/tasks/:id/suspend", async (req, res) => {
  try {
    const updated = await enqueueMutation(async () => {
      const tasks = loadTasks();
      const task = tasks.find(t => t.id === req.params.id);
      if (!task) throw { status: 404, body: { error: "Task not found" } };

      if (wouldExceedWip(tasks, "Suspended", task.id)) {
        throw { status: 400, body: { error: `WIP limit exceeded for Suspended. Limit: ${WIP_LIMITS["Suspended"]}` } };
      }
      task.state = "Suspended";
      task.updated_at = new Date().toISOString();
      recomputeAllPriorities(tasks);
      saveTasks(tasks);
      return task;
    });
    res.json(updated);
  } catch (err) {
    if (err && err.status && err.body) return res.status(err.status).json(err.body);
    console.error("PATCH /tasks/:id/suspend error:", err);
    res.status(500).json({ error: "Internal error" });
  }
});

app.post("/tasks/:id/dependencies", async (req, res) => {
  try {
    const updated = await enqueueMutation(async () => {
      const tasks = loadTasks();
      const task = tasks.find(t => t.id === req.params.id);
      if (!task) throw { status: 404, body: { error: "Task not found" } };

      const depId = req.body.dependencyId;
      if (!depId || !tasks.find(t => t.id === depId)) {
        throw { status: 400, body: { error: "Dependency task not found" } };
      }
      if (depId === task.id) throw { status: 400, body: { error: "Task cannot depend on itself" } };

      // Prevent cycles
      if (wouldCreateCycle(tasks, task.id, depId)) {
        throw { status: 400, body: { error: "Adding this dependency would create a cycle" } };
      }

      if (!task.dependencies) task.dependencies = [];
      if (!task.dependencies.includes(depId)) {
        task.dependencies.push(depId);
        task.updated_at = new Date().toISOString();

        const hasUnresolvedDeps = (task.dependencies || []).some(did => {
          const depTask = tasks.find(x => x.id === did);
          return !depTask || depTask.state !== "Done";
        });

        if (hasUnresolvedDeps && task.state !== "Done") {
          task.state = "Suspended";
          task.updated_at = new Date().toISOString();
        }

        recomputeAllPriorities(tasks);
        saveTasks(tasks);
      }

      return task;
    });
    res.json(updated);
  } catch (err) {
    if (err && err.status && err.body) return res.status(err.status).json(err.body);
    console.error("POST /tasks/:id/dependencies error:", err);
    res.status(500).json({ error: "Internal error" });
  }
});

app.post("/tasks/:id/remedy", async (req, res) => {
  try {
    const result = await enqueueMutation(async () => {
      const tasks = loadTasks();
      const blockedTask = tasks.find(t => t.id === req.params.id);
      if (!blockedTask) throw { status: 404, body: { error: "Blocked task not found" } };

      const deadline = (req.body.deadline !== undefined && req.body.deadline !== null) ? req.body.deadline : blockedTask.deadline;
      const description = (req.body.description && String(req.body.description).trim() !== '') ?
        req.body.description :
        `Remedy for: ${blockedTask.title}`;

      const titleRaw = req.body.title || `Remedy for ${blockedTask.title}`;
      const title = String(titleRaw).trim().slice(0, 200);

      const newTask = {
        id: genId(),
        title: title || `Remedy for ${blockedTask.title}`,
        description: description,
        state: "Ready",
        deadline: deadline,
        dependencies: [],
        picker: null,
        points_snapshot: undefined,
        picked_at: undefined,
        awarded: undefined,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        meta: {},
        remedy_for: blockedTask.id
      };

      tasks.push(newTask);

      blockedTask.dependencies = blockedTask.dependencies || [];
      if (!blockedTask.dependencies.includes(newTask.id)) blockedTask.dependencies.push(newTask.id);
      blockedTask.state = "Suspended";
      blockedTask.updated_at = new Date().toISOString();

      recomputeAllPriorities(tasks);
      saveTasks(tasks);

      return { blockedTask, remedyTask: newTask };
    });

    res.json(result);
  } catch (err) {
    if (err && err.status && err.body) return res.status(err.status).json(err.body);
    console.error("POST /tasks/:id/remedy error:", err);
    res.status(500).json({ error: "Internal error" });
  }
});

app.get("/tasks/active", (req, res) => {
  const tasks = loadTasks();
  const updated = computePriorities(tasks, new Date(), { MAX_WINDOW_days: 30, decay: 0.5, w_u: 0.4, w_i: 0.6 });
  const activeTasks = updated.filter(t => ["Ready", "InProgress"].includes(t.state)).sort((a, b) => b.priority - a.priority);
  res.json(activeTasks);
});

app.delete("/tasks/:id", async (req, res) => {
  try {
    const result = await enqueueMutation(async () => {
      let tasks = loadTasks();
      const initial = tasks.length;
      const exists = tasks.some(t => t.id === req.params.id);
      if (!exists) throw { status: 404, body: { error: "Task not found" } };

      // Remove the task
      tasks = tasks.filter(t => t.id !== req.params.id);

      // Remove dangling references from other tasks' dependencies
      tasks.forEach(t => {
        if (Array.isArray(t.dependencies)) {
          const filtered = t.dependencies.filter(d => d !== req.params.id);
          if (filtered.length !== t.dependencies.length) {
            t.dependencies = filtered;
            t.updated_at = new Date().toISOString();
          }
        }
      });

      recomputeAllPriorities(tasks);
      saveTasks(tasks);
      return { message: "Task deleted" };
    });
    res.json(result);
  } catch (err) {
    if (err && err.status && err.body) return res.status(err.status).json(err.body);
    console.error("DELETE /tasks/:id error:", err);
    res.status(500).json({ error: "Internal error" });
  }
});

app.post("/recompute", async (req, res) => {
  try {
    const tasks = await enqueueMutation(async () => {
      recomputeAllPriorities(); // loads & saves internally
      return loadTasks();
    });
    res.json({ message: "recomputed", count: tasks.length });
  } catch (err) {
    console.error("POST /recompute error:", err);
    res.status(500).json({ error: "Internal error" });
  }
});

/* users endpoints */

app.get("/users", (req, res) => {
  res.json(Object.values(loadUsers()));
});

app.get("/users/:id", (req, res) => {
  const users = loadUsers();
  const key = String(req.params.id).trim();
  const u = users[key];
  if (!u) return res.status(404).json({ error: "User not found" });
  res.json(u);
});

/* -------------------- server & periodic recompute -------------------- */

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`Server listening on port ${PORT}`));

setInterval(() => {
  enqueueMutation(async () => {
    try {
      recomputeAllPriorities();
      console.log("Periodic recompute done:", new Date().toISOString());
    } catch (err) {
      console.error("Periodic recompute error:", err);
    }
  }).catch(err => console.error("Periodic recompute enqueue failed:", err));
}, 10 * 60 * 1000);

